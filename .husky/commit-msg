#!/bin/bash

#
# This script is a commit-msg hook for Git and Husky.
# It validates the commit message against a set of rules.

# Get the path to the commit message file
commit_msg_file=$1

# Read the entire commit message
commit_msg=$(cat "$commit_msg_file")

# Rule 1: Check if the commit message is empty
if [ -z "$commit_msg" ]; then
    echo "Error: Commit message cannot be empty."
    exit 1
fi

# Get the first line of the commit message
first_line=$(echo "$commit_msg" | head -n 1)

# Define allowed prefixes for the first line
# This uses a regular expression to match the prefixes.
allowed_prefixes="^(feat|fix|docs|style|refactor|perf|chore|test)(\(.+\))?: "

# Rule 2: Validate the first line against the allowed prefixes
if ! echo "$first_line" | grep -qE "$allowed_prefixes"; then
    echo "Error: Invalid commit message format."
    echo ""
    echo "Message: $commit_msg"
    echo ""
    echo "Your commit message should start with one of the following prefixes:"
    echo "  - feat: (new feature)"
    echo "  - fix: (bug fix)"
    echo "  - docs: (documentation changes)"
    echo "  - style: (code formatting, semicolons, etc.; no code changes)"
    echo "  - refactor: (code changes that neither fixes a bug nor adds a feature)"
    echo "  - perf: (performance improvements)"
    echo "  - test: (adding missing tests)"
    echo "  - chore: (dev tools or general none-code related changes)"
    echo ""
    echo "Example: 'feat(authentication): add new login endpoint', 'fix #11: fixed the product uuid validation issue.'"
    exit 1
fi

# If all checks pass, the script exits successfully with status 0
echo "Commit message validated successfully."
exit 0
